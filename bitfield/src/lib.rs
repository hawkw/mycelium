#![doc = include_str!("../README.md")]
#![warn(missing_docs, rustdoc::broken_intra_doc_links)]
#![cfg_attr(not(test), no_std)]
#![cfg_attr(docsrs, feature(doc_cfg, doc_auto_cfg, doc_cfg_hide))]
#![cfg_attr(docsrs, doc(cfg_hide(docsrs)))]
#![cfg_attr(trace_macros, feature(trace_macros))]
use core::{convert::Infallible, fmt};

pub mod pack;
pub use self::pack::*;
mod bitfield;

/// An example of the code generated by the [`bitfield!`] macro.
///
/// > **Warning**: This module is included for DEMONSTRATION PURPOSES ONLY.
/// > This module is *not* part of the public API of this crate; it is provided
/// > as documentation only, and may change in non-breaking releases.
///
/// The [`ExampleBitfield`] type in this module was generated by the
/// following [`bitfield!`] invocation:
///
/// ```
#[doc = include_str!("example/example_bitfield.rs")]
/// ```
///
/// This module also contains two example types implementing the
/// [`FromBits`] trait, as a demonstration of how typed enums can
/// be used with the [`bitfield!`] macro.
///
///
/// [`ExampleBitfield`]: example::ExampleBitfield
#[cfg(any(test, docsrs, trace_macros))]
#[allow(missing_docs)]
pub mod example;

/// Trait implemented by values which can be converted to and from raw bits.
pub trait FromBits<B>: Sized {
    /// The error type returned by [`Self::try_from_bits`] when an invalid bit
    /// pattern is encountered.
    ///
    /// If all bit patterns possible in [`Self::BITS`] bits are valid bit
    /// patterns for a `Self`-typed value, this should generally be
    /// [`core::convert::Infallible`].
    type Error: fmt::Display;

    /// The number of bits required to represent a value of this type.
    const BITS: u32;

    /// Attempt to convert `bits` into a value of this type.
    ///
    /// # Returns
    ///
    /// - `Ok(Self)` if `bits` contained a valid bit pattern for a value of this
    ///   type.
    /// - `Err(Self::Error)` if `bits` is an invalid bit pattern for a value of
    ///   this type.
    fn try_from_bits(bits: B) -> Result<Self, Self::Error>;

    /// Convert `self` into a raw bit representation.
    ///
    /// In general, this will be a low-cost conversion (e.g., for `enum`s, this
    /// is generally an `as` cast).
    fn into_bits(self) -> B;
}

macro_rules! impl_frombits_for_ty {
   ($(impl FromBits<$($F:ty),+> for $T:ty {})+) => {
        $(

            $(
                impl FromBits<$F> for $T {
                    const BITS: u32 = <$T>::BITS;
                    type Error = Infallible;

                    fn try_from_bits(f: $F) -> Result<Self, Self::Error> {
                        Ok(f as $T)
                    }

                    fn into_bits(self) -> $F {
                        self as $F
                    }
                }
            )*
        )+
    }
}

macro_rules! impl_frombits_for_bool {
    (impl FromBits<$($F:ty),+> for bool {}) => {
        $(
            impl FromBits<$F> for bool {
                const BITS: u32 = 1;
                type Error = Infallible;

                fn try_from_bits(f: $F) -> Result<Self, Self::Error> {
                    Ok(if f == 0 { false } else { true })
                }

                fn into_bits(self) -> $F {
                    if self {
                        1
                    } else {
                        0
                    }
                }
            }
        )+
    }
}

impl_frombits_for_ty! {
    impl FromBits<u8, u16, u32, u64, usize> for u8 {}
    impl FromBits<u16, u32, u64, usize> for u16 {}
    impl FromBits<u32, u64, usize> for u32 {}
    impl FromBits<u32, usize> for usize {}
    impl FromBits<u64> for u64 {}

    impl FromBits<u8, u16, u32, u64, usize> for i8 {}
    impl FromBits<u16, u32, u64, usize> for i16 {}
    impl FromBits<u32, u64, usize> for i32 {}
    impl FromBits<u32, usize> for isize {}
    impl FromBits<u64> for i64 {}
}

impl_frombits_for_bool! {
    impl FromBits<u8, u16, u32, u64, usize> for bool {}
}

#[cfg(target_pointer_width = "64")]
impl_frombits_for_ty! {
    impl FromBits<u64> for usize {}
}

#[cfg(target_pointer_width = "64")]
impl_frombits_for_ty! {
    impl FromBits<u64> for isize {}
}
