use crate::arch;
use maitake::{sync::RwLock, time};
use mycelium_util::sync::{spin, Lazy};

pub(crate) type SystemRng = merlin::TranscriptRng;

/// Sponge for entropy generated by hardware entropy sources.
///
/// We are not, in fact, using `merlin` to prove a public-coin argument
/// transcript, but instead, we are using its internal `#![no_std]`-compatible
/// [STROBE implementation] as a sponge for entropy generated by system hardware
/// that can be used to quickly produce a fast and secure RNG.
///
/// [STROBE implementation]: https://merlin.cool/transcript/rng.html
static SPONGE: Lazy<RwLock<merlin::Transcript>> = Lazy::new(init);

pub(crate) async fn entropy_upkeep(interval: time::Duration) {
    // buffer for the entropy source output
    tracing::info!("spawned RNG entropy upkeep task");
    let mut buf = [0u8; 64];
    loop {
        // clippy tells us that this auto-deref would be done by the compiler,
        // but
        #[allow(clippy::explicit_auto_deref)]
        fill_randomness(&mut *SPONGE.write().await, &mut buf);
        time::sleep(interval).await;
    }
}

/// Initialize a new random number generator.
///
/// This function spins if the RNG entropy sponge is currently being updated.
#[must_use]
pub(crate) fn new_rng_blocking() -> SystemRng {
    let mut boff = spin::Backoff::new();
    let sponge = loop {
        if let Some(sponge) = SPONGE.try_read() {
            break sponge;
        }
        boff.spin();
    };
    build_rng(&sponge)
}

/// Initialize a new random number generator.
///
/// This function waits until the RNG entropy sponge is done being updated.
#[allow(dead_code)] // i'll use this later
pub(crate) async fn new_rng() -> SystemRng {
    let sponge = SPONGE.read().await;
    build_rng(&sponge)
}

fn build_rng(sponge: &merlin::Transcript) -> SystemRng {
    tracing::debug!("building a new RNG");
    sponge
        .build_rng()
        .finalize(&mut arch::entropy::RekeyRng::new())
}

fn init() -> RwLock<merlin::Transcript> {
    tracing::info!("initializing system RNG...");
    let mut sponge = merlin::Transcript::new(b"rng");
    let mut buf = [0u8; 64];
    fill_randomness(&mut sponge, &mut buf);

    tracing::info!("RNG initialized!");
    RwLock::new(sponge)
}

fn fill_randomness(sponge: &mut merlin::Transcript, buf: &mut [u8]) {
    // Number of iterations of filling the sponge to do if we haven't run out of
    // rdrand randomness.
    //
    // This is just so that the bg task will never loop infinitely if rdrand is
    // refilling too fast.
    const MAX_ITERS: usize = 64;
    for _ in 0..MAX_ITERS {
        let bytes = arch::entropy::fill_bytes(buf);
        sponge.append_message(b"entropy", &buf[..bytes]);
        if bytes < buf.len() {
            // called rdrand too much, i guess!
            break;
        }
    }
}
